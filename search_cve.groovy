import groovy.transform.EqualsAndHashCode

import groovy.transform.ToString
import org.artifactory.repo.RepoPathFactory
import org.artifactory.request.RequestThreadLocal
import org.artifactory.resource.ResourceStreamHandle
import org.artifactory.util.HttpClientConfigurator
import org.apache.http.client.methods.*
import org.apache.http.entity.StringEntity
import org.artifactory.search.aql.*
import groovy.json.JsonSlurper

import java.util.stream.Collectors


/*
THIS IS WIP, DEMO and generally VERY UGLY code. DO NOT JUDGE!
 */


@EqualsAndHashCode
@ToString
class Pair<F, S> {
    F first
    S second

    Pair(F first, S second) {
        this.first = first
        this.second = second
    }
}

interface JFrogEntity {
    String getSha()
}

@ToString
class Artifact implements JFrogEntity {
    String name
    String sha
    Set<Pair<String, String>> downloadedBy = new HashSet<>()

    @Override
    String toString() {
        return "Artifact: $name downloadedBy: ${downloadedBy}"
    }
}

@ToString
class Build implements JFrogEntity {
    String application
    String buildName
    String buildNumber
    String sha
    boolean usedInProd

    @Override
    String toString() {
        return "Build: ${buildName} version ${buildNumber}  belongs to ${application} application"
    }
}

@ToString
class ReleaseBundle implements JFrogEntity {
    boolean downloaded
    Set<Build> builds
    String compId
    Set<String> distributedTo = new HashSet<>()
    String sha

    @Override
    String toString() {
        return "Release Bundle ${compId} has ${builds?.size()} builds and was distributed to: ${distributedTo}"
    }
}

@ToString
class Node {
    JFrogEntity jFrogEntity
    Set<Node> children = new HashSet<>()
    Set<Node> parent = new HashSet<>()

    @Override
    String toString() {
        return "${jFrogEntity} ----- children amount: ${children.size()} and parens ${parent.size()}"
    }
}


String pkgType2XrayScheme(String pkgType) {
    switch (pkgType) {
        case "Maven": return "gav"
        case "Docker": return "docker"
        case "RPM": return "rpm"
        case "Debian": return "deb"
        case "NuGet": return "nuget"
        case "NPM": return "npm"
        case "Python": return "pip"
        case "Composer": return "composer"
        case "Golang": return "go"
        case "Alpine": return "alpine"
        default:
            log.error("unknown pkg_type: " + pkgType + ". going to use generic")
            return "generic" // TODO: this requires the sha256:FFFFFFFFF syntax for comp ID :(
    }
}

// return all ancestors
// compSha could be null
Set<Pair<String, String>> findRBAncestors(String baseURL, String compId, Set cache, Map anCache, String compSha,
        Map<String, Node> theDependencyGraph) {
    /* if (cache.contains(compId)) {
         return new HashSet()
     }*/

    log.error("findAncestors: " + compId)

    Set<Pair<String, String>> pairs = fetchNext(baseURL, compId, true, anCache, compSha)


    Set<Pair<String, String>> results = new HashSet()
    pairs.each {
        //if (it.component_id.startsWith("releaseBundle://")) {
        //    results.add(component_id)
        //}

        // Avoid identity arrows
        if (compId != it.first) {
            Pair<String, String> res = new Pair(it.first, it.second)
            results.add(res)
            log.error("Adding to result: " + res.first)

            Node ansNode = theDependencyGraph.getOrDefault(it.second, new Node())
            Node currentNode = theDependencyGraph.get(compSha)
            currentNode.parent.add(ansNode)
            ansNode.children.add(currentNode)
            if (it.first.startsWith("releaseBundle://")) {
                ReleaseBundle rr = new ReleaseBundle()
                rr.sha = it.second
                rr.compId = it.first
                ansNode.jFrogEntity = rr
            } else if (it.first.startsWith("build://")) {
                Build bb = new Build()
                bb.sha = it.second
                String[] bbSeg = it.first.substring("build://".length()).split(":")
                bb.buildName = bbSeg[0]
                bb.buildNumber = bbSeg[1]
                ansNode.jFrogEntity = bb
            } else {
                Artifact aa = new Artifact()
                aa.sha = it.second
                aa.name = it.first
                ansNode.jFrogEntity = aa
            }
            theDependencyGraph.put(it.second, ansNode)
            results.addAll(findRBAncestors(baseURL, it.first, cache, anCache, it.second, theDependencyGraph))
        } else {
            log.error("FOUND A problem with: ${compId}")
        }
    }
    //  cache.add(compId)
    log.error("results size: ${results.size()}")
    return results
}

// Need this method cause no API to get sha of package (will need to ask for ancestors and then back to descendants)
// I know, using nulls, return null when this is a leaf (we will not need it in the results)
// TODO: convert to Optional
def findShaOfStartingPackages(String baseURL, String compId) {
    Set<Pair<String, String>> pp = fetchNext(baseURL, compId, true, new HashMap(), null)
    if (pp.size() == 0) {
        return null
    }
    Set<Pair<String, String>> pairs = fetchNext(baseURL, pp.iterator().next().first, false, new HashMap(), null)
    String result = ""
    pairs.each {
        if (it.first == compId) {
            result = it.second
        }
    }
    return result
}

// returns a set of pairs (compId, sha)
// compSha could be null
Set<Pair<String, String>> fetchNext(String baseURL, String compId, boolean ancestors, Map cache, String compSha) {
    /*if (ancestors && cache.containsKey(compId)) {
        return cache.get(compId)
    }*/
    log.error("fetchNext: " + compId + " ancestors: " + ancestors)

    String url = baseURL + "/xray/ui/component/navigator"
    if (ancestors) {
        url = url + "?ancestors=true"
    } else {
        url = url + "?descendants=true"
    }
    String pathToAdd = ""
    if (compId.startsWith("docker://") && compSha != null) {
        // There is a bug in the UI API, need to pass the location as path argument here
        List<String> localRepos = repositories.getLocalRepositories();
        searches.aql("""items.find({"sha256":"${compSha}"}).include("repo", "path","name")""",
                new AqlResultHandler() {
                    @Override
                    void handle(AqlResult result) {

                        result.each { rrrr ->

                            String repo = rrrr.get("repo")
                            String name = rrrr.get("name")
                            String path = rrrr.get("path")

                            if (pathToAdd == "") {
                                // TODO: this is ignoring federated repos. Not correct. need to loop over all of
                                //  these and find the one that xray api doesn't fail on.
                                if (localRepos.contains(repo)) {
                                    pathToAdd = ",\"path\":\"${repo}/${path}/${name}\""
                                }
                            }
                        }
                    }
                }
        )
    }


    def method3 = new HttpPost(url.toString())
    method3.addHeader("Content-Type", "application/json")
    method3.addHeader('Accepts', "application/json")
    method3.setEntity(new StringEntity("{\"component_id\":\"" + compId + "\"${pathToAdd}}"))
    String authVal = RequestThreadLocal.getRequest().getHeader("authorization")
    method3.addHeader("authorization", authVal);
    def clientConf = new HttpClientConfigurator()
    clientConf.soTimeout(3000).connectionTimeout(3000)
    def client = clientConf.retry(0, false).client
    def xrayResp = client.execute(method3)

    def resp1 = new JsonSlurper().parse(new InputStreamReader(xrayResp.entity.content))
    Set<Pair<String, String>> results = new HashSet<>()
    log.error("FETCHNEXT resutls: " + resp1)
    resp1.each {
        results.add(new Pair(it.component_id, it.sha256))
    }
    xrayResp.close()
    //    cache.put(compId, results)
    return results
}

Set<String> findCVE(String baseURL, String cve) {
    String url = baseURL + "/xray/api/v1/component/searchByCves"
    def method3 = new HttpPost(url.toString())
    method3.addHeader("Content-Type", "application/json")
    method3.addHeader('Accept', "application/json")

    method3.setEntity(new StringEntity("{\"cves\":[\"" + cve + "\"]}"))

    def authVal = RequestThreadLocal.getRequest().getHeader("authorization")
    method3.addHeader("authorization", authVal);
    def clientConf = new HttpClientConfigurator()
    clientConf.soTimeout(3000).connectionTimeout(3000)
    def client = clientConf.retry(0, false).client
    def xrayResp = client.execute(method3)

    def resp1 = new JsonSlurper().parse(new InputStreamReader(xrayResp.entity.content))


    Set<String> results = new HashSet<>()
    if (resp1.size() > 0) {
        resp1[0].components.each {
            // TODO: yeah, this doesn't make any sense for generic packages returned (the below composition doesn't
            //  make any sense. However, not expected generic package types here :/
            results.add(pkgType2XrayScheme(it.package_type) + "://" + it.name + ":" + it.version)
        }
    }
    xrayResp.close()
    return results
}


Set<Pair<String, String>> getRBShas(String baseURL, String rbCompId) {
    def arr = rbCompId.split(":")
    def url = baseURL + "/distribution/api/v1/release_bundle/" + arr[1].substring(2) + "/" + arr[2] + "/"
    log.error("Distribution: " + url)
    def method3 = new HttpGet(url.toString())
    method3.addHeader('Accepts', "application/json")
    def authVal = RequestThreadLocal.getRequest().getHeader("authorization")
    method3.addHeader("authorization", authVal);
    def clientConf = new HttpClientConfigurator()
    clientConf.soTimeout(3000).connectionTimeout(3000)
    def client = clientConf.retry(0, false).client
    def xrayResp = client.execute(method3)

    def resp1 = new JsonSlurper().parse(new InputStreamReader(xrayResp.entity.content))
    Set<Pair<String, String>> results = new HashSet()
    resp1.artifacts.each {
        results.add(new Pair(it.checksum, it.sourceRepoPath))
    }
    xrayResp.close()
    return results
}

Set<Pair<String, String>> getEdgesURL(String baseURL, String rbCompId, Map sites) {
    String[] arr = rbCompId.split(":")
    def url = baseURL + "/distribution/api/v1/release_bundle/" + arr[1].substring(2) + "/" + arr[2] + "/distribution"

    def method3 = new HttpGet(url.toString())
    method3.addHeader('Accepts', "application/json")
    def authVal = RequestThreadLocal.getRequest().getHeader("authorization")
    method3.addHeader("authorization", authVal);
    def clientConf = new HttpClientConfigurator()
    clientConf.soTimeout(3000).connectionTimeout(3000)
    def client = clientConf.retry(0, false).client
    def xrayResp = client.execute(method3)

    def resp1 = new JsonSlurper().parse(new InputStreamReader(xrayResp.entity.content))
    HashSet<Pair<String, String>> results = new HashSet<>()
    resp1.each { dist ->
        if (dist != null) {
            dist.sites.each { site ->
                String siteName = site.target_artifactory.name
                if (site.status == "Completed") {
                    String targetURL = sites.get(siteName)
                    results.add(new Pair<>(siteName, targetURL))
                    log.error("RB ${rbCompId} distributed to: ${siteName}  at: ${targetURL}")
                }
            }
        }
    }
    xrayResp.close()

    return results
}


def site2url(String baseURL) {

    String url = baseURL + "/mc/api/v1/jpds"

    def method3 = new HttpGet(url.toString())
    method3.addHeader('Accepts', "application/json")
    def authVal = RequestThreadLocal.getRequest().getHeader("authorization")
    method3.addHeader("authorization", authVal);
    def clientConf = new HttpClientConfigurator()
    clientConf.soTimeout(3000).connectionTimeout(3000)
    def client = clientConf.retry(0, false).client
    def xrayResp = client.execute(method3)

    def resp1 = new JsonSlurper().parse(new InputStreamReader(xrayResp.entity.content))
    def results = new HashMap()

    resp1.each { jpd ->
        results.put(jpd.name, jpd.url)
        log.error("TOPOLOGY: " + jpd.name + " -> " + jpd.url)
    }
    xrayResp.close()

    return results
}

Map<String, String> whoDownloaded(String edgeURL, Set shas) {
    def url = edgeURL + "artifactory/api/search/aql"

    def method3 = new HttpPost(url.toString())
    method3.addHeader("Content-Type", "text/plain")
    method3.addHeader('Accept', "application/json")

    StringBuilder shaCriteria = new StringBuilder()

    String prefix = ""

    shas.each { s256 ->
        shaCriteria.append("${prefix}{\"\$and\":[")
        shaCriteria.append("{\"sha256\" : \"$s256\"}")
        shaCriteria.append(",")
        shaCriteria.append("{\"stat.downloaded_by\" : {\"\$ne\":null}}]}")
        prefix = ","
    }

    String query = """items.find({
                "\$or":
            [
                 ${shaCriteria.toString()}
            ]
              }).include("sha256","repo", "path", "name","stat.downloaded_by")"""

    log.error(query)

    method3.setEntity(new StringEntity(query))

    method3.addHeader("authorization", "Basic YWRtaW46SkZyMGcwNjAx");
    def clientConf = new HttpClientConfigurator()
    clientConf.soTimeout(3000).connectionTimeout(3000)
    def client = clientConf.retry(0, false).client
    def xrayResp = client.execute(method3)

    def resp1 = new JsonSlurper().parse(new InputStreamReader(xrayResp.entity.content))
    Map<String, String> results = new HashMap()


    resp1.results.each { row ->
        String fullName = "${row.repo}/${row.path}/${row.name}"
        results.put(row.sha256, row.stats.downloaded_by)
        log.error("ROW: " + fullName + " -> " + row.stats.downloaded_by)
    }
    xrayResp.close()

    return results
}

def findBranchSha(String baseURL, String branch) {
    def url = baseURL + "/branches"

    def method3 = new HttpGet(url.toString())
    method3.addHeader('Accept', "application/json")
    def clientConf = new HttpClientConfigurator()
    clientConf.soTimeout(3000).connectionTimeout(3000)
    def client = clientConf.retry(0, false).client
    def xrayResp = client.execute(method3)

    def resp1 = new JsonSlurper().parse(new InputStreamReader(xrayResp.entity.content))
    String result = ""
    resp1.each { row ->
        if (row.name == branch) {
            result = row.commit.sha
        }
    }
    xrayResp.close()

    return result
}

def createBranch(String baseURL, String fromBranchSha, String newBranchName) {
    def url = baseURL + "/git/refs"
    log.error("CB url: ${url}")


    def method3 = new HttpPost(url.toString())

    method3.addHeader("Content-Type", "application/json")
    method3.addHeader('Accept', "application/json")
    method3.addHeader("authorization",
            "Basic ZnJhbmt6aHUyMDAzOmdocF81Qk5oWTNvMlB3aW5iUUJsZEJ5ZmduTjh6TmtiVUY0UUNqdDY=");
    String cont = "{\"ref\":\"refs/heads/${newBranchName}\",\"sha\":\"${fromBranchSha}\"}"
    log.error("CB cont: ${cont}")
    method3.setEntity(new StringEntity(cont))


    def clientConf = new HttpClientConfigurator()
    clientConf.soTimeout(3000).connectionTimeout(3000)
    def client = clientConf.retry(0, false).client
    def xrayResp = client.execute(method3)
    def resp1 = new JsonSlurper().parse(new InputStreamReader(xrayResp.entity.content))
    log.error("RESPONSE CREAYE BRANCHL : ${resp1}")


    xrayResp.close()

}


// from is the branch with the changes
def createDummyFile(String baseURL, String branchName, String fileName, String content, String theCVE) {
    def url = baseURL + "/contents/${fileName}"
    def method3 = new HttpPut(url.toString())

    method3.addHeader("Content-Type", "application/json")
    method3.addHeader("authorization",
            "Basic ZnJhbmt6aHUyMDAzOmdocF81Qk5oWTNvMlB3aW5iUUJsZEJ5ZmduTjh6TmtiVUY0UUNqdDY=");
    method3.addHeader('Accept', "application/json")
    String cont = "{\"message\":\"Please fix ${theCVE}\",\"content\":\"${content}\",\"branch\":\"${branchName}\"}"

    method3.setEntity(new StringEntity(cont))
    def clientConf = new HttpClientConfigurator()
    clientConf.soTimeout(3000).connectionTimeout(3000)
    def client = clientConf.retry(0, false).client
    def xrayResp = client.execute(method3)
    def resp1 = new JsonSlurper().parse(new InputStreamReader(xrayResp.entity.content))
    log.error("RESPONSE CREAYE file : ${resp1}")
    xrayResp.close()

}


def createSNTicket(String cve, String cveBOM, String pullRq) {
/*
 var cveBOM = body.cveBOM;
        var cve = body.cve;
    var pullReq = body.pull_reqs;
 */


    def serviceNowURL = "https://dev92696.service-now.com/api/688588/extract_cve"
    def method3 = new HttpPost(serviceNowURL)
    method3.addHeader("Content-Type", "application/json")
    method3.addHeader('Accepts', "application/json")
    method3.setEntity(
            new StringEntity(
                    "{" +
                            "\"cveBOM\": " + cveBOM + "" +
                            ",\"cve\": \"" + cve + "\"" +
                            ",\"pullReq\": \"" + pullRq + "\"" +
                            "}"))

    def clientConf = new HttpClientConfigurator()
    clientConf.soTimeout(3000).connectionTimeout(3000)

    def client = clientConf.retry(0, false).client

    def serviceNowResp = client.execute(method3)

    serviceNowResp.close()




}




// from is the branch with the changes
String createPullRequest(String baseURL, String fromBranchName, String toBranchName, String message, String title) {
    def url = baseURL + "/pulls"
    log.error("CB url: ${url}")


    def method3 = new HttpPost(url.toString())

    method3.addHeader("Content-Type", "application/json")
    method3.addHeader("authorization",
            "Basic ZnJhbmt6aHUyMDAzOmdocF81Qk5oWTNvMlB3aW5iUUJsZEJ5ZmduTjh6TmtiVUY0UUNqdDY=");
    method3.addHeader('Accept', "application/json")
    String cont = "{\"head\":\"${fromBranchName}\",\"base\":\"${toBranchName}\",\"title\":\"${title}\"," +
            "\"body\":\"${message}\"}"

    method3.setEntity(new StringEntity(cont))


    def clientConf = new HttpClientConfigurator()
    clientConf.soTimeout(3000).connectionTimeout(3000)
    def client = clientConf.retry(0, false).client
    def xrayResp = client.execute(method3)
    def resp1 = new JsonSlurper().parse(new InputStreamReader(xrayResp.entity.content))
    log.error("RESPONSE CREAYE PR : ${resp1}")
    xrayResp.close()
    return resp1.html_url

}


boolean isChildADescendant(String childSHA, String ansSHA, Map<String, Node> theDependencyGraph) {
    if (childSHA == ansSHA) {
        return true
    }
    Set<Node> parents = theDependencyGraph.get(childSHA).parent
    return parents.stream().anyMatch({ isChildADescendant(it.jFrogEntity.sha, ansSHA, theDependencyGraph) })
}


executions {

    // Returns RBs and vulnerable shas in them.
    // input params in the body:
    //    cve- mandatory, the CVE to extract
    //    secops - optional, the secops email owning the extraction
    //
    searchCVE { params, ResourceStreamHandle body ->
        def payLoad = new JsonSlurper().parse(body.getInputStream())
        def req = RequestThreadLocal.context.get()?.requestThreadLocal
        String burl = req.baseUrl.replace("/artifactory", "")
        String theCVE = payLoad.cve
        String secops = payLoad.secops
        Set leaves = findCVE(burl, theCVE)
        log.error("leaves having the cve: ")
        leaves.each { log.error(it) }
        Map sites = site2url(burl)


        // we will collect only shas
        Set<String> shas = new HashSet()
        Map<String, String> rbs = new HashMap()
        Map<String, Node> theDependencyGraph = new HashMap<>()
        leaves.each { leaf ->
            def result = findShaOfStartingPackages(burl, leaf)

            /*
            Construct Node
             */
            Node node = new Node()
            // assume leaves are artifacts (and not builds or RBs)
            Artifact a = new Artifact()
            a.sha = result
            a.name = leaf
            node.jFrogEntity = a


            if (result != null) {
                theDependencyGraph.put(result, node)
                shas.add(result)
                // we will also populate the node here (very ugly, and will need to traverse the tree alot, by hey :) )
                Set<Pair<String, String>> pairs = findRBAncestors(burl, leaf, new HashSet(), new HashMap(), result,
                        theDependencyGraph)
                pairs.each { ppp ->
                    if (ppp.first.startsWith("releaseBundle://")) {
                        rbs.put(ppp.first, ppp.second)
                    } else {
                        shas.add(ppp.second)
                    }

                }
            }
        }



        // Map endResult = new HashMap()
        Map demoResult = new HashMap()

        rbs.each { rbIt ->
            String rb = rbIt.key
            //endResult.put(rb, new HashMap())

            // a pair of sha and location
            Set<Pair<String, String>> rbContents = getRBShas(burl, rb)

            // a pair of sha and location
            Set<Pair<String, String>> r5 = rbContents.stream().filter({ shas.contains(it.first) }).collect(
                    Collectors.toSet())
            //.intersect(shas)


            Set<Pair<String, String>> targetURLs = getEdgesURL(burl, rb, sites)

            ////// now we need to know who downloaded it

            boolean hasBeenDownloaded = false
            targetURLs.each { edgeURL ->
                Map<String, String> downloads = whoDownloaded(edgeURL.second,
                        r5.stream().map({ it.first }).collect(Collectors.toSet()))
                downloads.each { down ->
                    //  Set userDownloads = endResult.get(rb).getOrDefault(down.value, new HashSet())
                   // userDownloads.add(new Pair(down.key, edgeURL.first))
                    //  endResult.get(rb).put(down.value, userDownloads)
                    hasBeenDownloaded = true
                    ((ReleaseBundle) theDependencyGraph.get(rbIt.value).jFrogEntity).distributedTo.add(edgeURL.first)
                    ((Artifact) theDependencyGraph.get(down.key).jFrogEntity).downloadedBy.add(
                            new Pair<>(down.value, edgeURL.first))
                }

            }

            /*
        FOR THE CVE Extraction Demo, we will only need the VCSs for the vulenrable artifacts in a downloaded rb
        (Will not delete other code/data, as it may server future demos and POCs
         */



            // r5 has the vulnerable artifacts
            // find all the builds
            // I will do it the safe way and not in a single AQL as I'm uncertain about referential transperancy
            StringBuilder shaQ = new StringBuilder()
            String p9 = ""
            // TOFO: Fix to use also location
            Set<String> shasIncludedInRBs = r5.stream().map({ it.first }).collect(Collectors.toSet())

            shasIncludedInRBs.each { filtersha ->
                shaQ.append("${p9}{\"\$and\":[")

                shaQ.append("{\"sha256\" : \"$filtersha\"}")
                shaQ.append(",")
                shaQ.append("{\"@build.name\" : {\"\$ne\":null}}]}")
                p9 = ","
            }
            Map<Pair<String, String>, Boolean> buildsWithCVE = new HashMap()
            searches.aql("""items.find({"\$or":[${shaQ}]}).include("sha256","@build.name","@build.number")""",
                    new AqlResultHandler() {
                        @Override
                        void handle(AqlResult result) {
                            result.each { rrrr ->
                                String r256 = rrrr.get("sha256")
                                boolean isBuildUsedInProd = shasIncludedInRBs.contains(r256)
                                String buildName = ""
                                String buildNumber = ""
                                List props = rrrr.get("properties")
                                props.each { pep ->
                                    if (pep.key == "build.name") {
                                        buildName = pep.value
                                    }
                                    if (pep.key == "build.number") {
                                        buildNumber = pep.value
                                    }
                                }
                                Pair<String, String> theKey = new Pair(buildName, buildNumber)
                                buildsWithCVE.put(theKey, true)
                                log.error(
                                        "BUILD FOUND: ${buildName} ver: ${buildNumber}")
                            }
                        }
                    }

            )

            theDependencyGraph.values().stream().filter({it.jFrogEntity instanceof Build}).each {
                Build thisB = it.jFrogEntity
                Pair<String, String> theKey = new Pair(thisB.buildName, thisB.buildNumber)
                buildsWithCVE.putIfAbsent(theKey, false)
            }

            // for each build find the VCS
            StringBuilder buildQ = new StringBuilder()
            String p99 = ""
            buildsWithCVE.keySet().each { bC ->
                buildQ.append("${p99}{\"\$and\":[")

                buildQ.append("{\"name\" : \"${bC.first}\"}")
                buildQ.append(",")
                buildQ.append("{\"number\" : \"${bC.second}\"}]}")
                p99 = ","
            }

            Set gitRepos = new HashSet()
            // TODO: need to add build.name and build.number to the include clause (need that for the DBOM)
            searches.aql("""builds.find({"\$or":[${buildQ}]}).include("name","number", "property.*")""",
                    new AqlResultHandler() {
                        @Override
                        void handle(AqlResult result) {
                            result.each { rrrr ->
                                String rsBNa = rrrr.get("build.name")
                                String rsBNu = rrrr.get("build.number")
                                log.error("JUST MAKING SURE: ${rsBNa} ${rsBNu}")
                                List bProps = rrrr.get("build.properties")
                                bProps.each { pp4 ->
                                    //                                        log.error("X " + pp4)
                                    if (pp4.get("build.property.key").endsWith("gitRepoRepositoryHttpsUrl")) {
                                        log.error("git repo found: " + pp4.get("build.property.value"))
                                        String theAppGit = pp4.get("build.property.value")


                                        // TODO: again, not efficient
                                        theDependencyGraph.values().stream().filter({ aNode ->
                                            if (aNode.jFrogEntity instanceof Build) {
                                                Build cand = aNode.jFrogEntity
                                                return (cand.getBuildName() == rsBNa && cand.getBuildNumber() == rsBNu)
                                            } else {
                                                return false
                                            }
                                        }).findFirst().map({
                                            t1 ->
                                                ((Build) t1.jFrogEntity).application = theAppGit
                                                if (buildsWithCVE.get(new Pair<>(rsBNa, rsBNu))) {
                                                    gitRepos.add(theAppGit)
                                                    ((Build) t1.jFrogEntity).usedInProd = true
                                                }
                                        })
                                    }
                                }

                            }
                        }
                    }

            )
            if (hasBeenDownloaded) {
                demoResult.put(rb, gitRepos)
            }
            /*
               ReleaseBundle rbb = new ReleaseBundle()
               rbb.compId = rb
               rbb.downloaded = hasBeenDownloaded
               rbb.distributedTo = targetURLs.stream().map({it.first}).collect(Collectors.toSet())
               rbb.builds = new HashSet<>()
               buildsWithCVE.each {
                   Build b = new Build()
                   b.buildName = it.first
                   b.buildNumber = it.second
                   rbb.builds.add(b)

               }
               */

        }

        theDependencyGraph.each {
            log.error("DBOM: ${it.key}: ${it.value}")
        }
        ////// Creating PRs
        String branchSuffix = "-${(int) (Math.random() * 100000 + 1)}"
        Set gits = new HashSet()
        List<String> prURLs = new ArrayList<>()
        demoResult.each({ gits.addAll(it.value) })
        gits.each {




                String git = it
                String[] gitSegments = git.split("/")
                String githubURL = "https://api.github.com/repos/${gitSegments[3]}/${gitSegments[4].replaceAll("\\.git\$", "")}"
                        log.error("GIT: ${githubURL}")
                        // find the branch main
                        String fromBranchSha = findBranchSha(githubURL, "main")
                        log.error("BRANCH SHA: ${fromBranchSha}")
                        // create a branch with CVE and Ticket Number
                        String newBranchName = "fix-${theCVE}${branchSuffix}"
                        createBranch(githubURL, fromBranchSha, newBranchName)
                        // create a pull request
                        createDummyFile(githubURL, newBranchName, "FIXME",
                                "Please fix CVE ${theCVE}".bytes.encodeBase64().toString(), theCVE)

                        String secopsSuffix = ""
                    if (secops != null) {
                        secopsSuffix = "\nPlease contact: ${secops} for any question."
                    }
                    String prURL = createPullRequest(githubURL, newBranchName, "main",
                            "Please fix CVE: ${theCVE}, with ticket: [NOT_IMPLEMENTED]${secopsSuffix}", "fix CVE " +
                            "${theCVE}")
                    prURLs.add(prURL)
                }




            def output = new StringBuilder("")

            String up1 = ""
            output.append("[")
            theDependencyGraph.entrySet().stream().filter({ it.value.jFrogEntity instanceof ReleaseBundle }).each {
                ReleaseBundle rr1 = (ReleaseBundle) it.value.jFrogEntity
                String[] segs = rr1.compId.split(":")
                output.append("${up1}{")
                output.append("\"release_bundle_name\":\"${segs[1].substring(2)}\"\n")
                output.append(",\"release_bundle_version\":\"${segs[2]}\"\n")
                output.append(",\"distributed_to\":\n")
                output.append("[\n")
                String up2 = ""
                rr1.distributedTo.each { target ->
                    output.append("${up2}\"${target}\"")
                    up2 = ","
                }
                output.append("]\n")
                output.append(",\"affected_artifacts\":\n")
                output.append("[")
                up2 = ""

                String rbSHA = it.key
                // WILL DO THIS REALLY REALLY INEFFICIENT. I MEAN REALLY. TOO TIRED TO RESOLVE GRAPHS NOW
                theDependencyGraph.entrySet().stream().filter(
                        { isChildADescendant(it.key, rbSHA, theDependencyGraph) }).each {
                    if (it.value.jFrogEntity instanceof Artifact) {
                        Artifact arrIt = (Artifact) it.value.jFrogEntity
                        output.append("${up2}{")
                        output.append("\"artifact_name\":\"${arrIt.name}\"\n")
                        output.append(",\"downloads\":\n")
                        String up3 = ""
                        output.append("[\n")
                        arrIt.downloadedBy.each {
                            output.append("${up3}{\n")
                            output.append("\"target_edge\":\"${it.second}\"\n")
                            output.append(",\"user\":\"${it.first}\"\n")
                            output.append("}\n")
                        }
                        output.append("]\n")
                        output.append("}")
                        up2 = ","
                    }
                }
                output.append("]")

                output.append("}")
                up1 = ","
            }

            theDependencyGraph.entrySet().stream().filter({ it.value.jFrogEntity instanceof Build }).each {
                Build cBuild = it.value.jFrogEntity
                output.append("${up1}{")
                output.append("\"build_name\":\"${cBuild.getBuildName()}\"\n")
                output.append(",\"build_number\":\"${cBuild.getBuildNumber()}\"\n")
                output.append(",\"application\":\"${cBuild.getApplication()}\"\n")
                output.append(",\"in_production\":\"${cBuild.usedInProd}\"\n")
                output.append("}")
                up1 = ","
            }
            output.append("]")

            message = output.toString()
        createSNTicket(theCVE,  output.toString(), prURLs.join(", "))
        }






    }
